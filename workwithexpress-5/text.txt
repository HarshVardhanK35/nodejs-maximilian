what is express?
----------------
- writing a server side code in node.js is a complex way
  - ex: we wrote so much to parse an incoming request in node

- however express also does not have in-built way to parse the data... but we install another package to parse
- we also use framework
  - framework is a set of helper functions, tools and rules that help you build an application
____________________________________________________________________________________________________________________________________________________________________________________________________

Installing Express.JS
---------------------
- install express as production dependency but not as dev-dependency
  - "npm install --save express"

use express
---
1. app.js -> import the express package -> using: const express = require('express')

2. to create an express application we use:
  - const app = express()
____________________________________________________________________________________________________________________________________________________________________________________________________

Adding Middlewares
------------------
- express is all about middlewares
- the incoming requests funneled through a bunch of functions by express
  - the request hooked up with multiple functions until it gives us a response
  - this allows us to split the code into multiple blocks or pieces

- we add a middleware before creating a server and after creating the app with express()

app.use()
---
- use allows us to add new middleware functions
- pass in a function into "app.use()" and that function can be executed for every incoming requests
  - that function passed takes in three parameters those are
    - 'req', 'res', 'next'

app.use((req, res, next) => {})

next()
---
- we are passing a function to the 'use' method in app and the passed function taking another function that is "next()"
- next()
- allows the request to travel along the other middlewares
  - if called on 1st middleware... it travels to next or 2nd middleware
    - else it does not
  -
-

experiment with
---
const http = require('http')
const express = require('express')

const app = express()

// 1st middleware
app.use((req, res, next) => {
  console.log('In 1st middleware')
  // next()                                          // call it and check the status of request
})

// 2nd middleware
app.use((req, res, next) => {
  console.log('Inside 2nd middleware')
})

const server = http.createServer(app)
server.listen(3000)
____________________________________________________________________________________________________________________________________________________________________________________________________

How middleware works?
---------------------
- the main advantage of express is it will automatically set the header on it's own.
  - however we can define it on our own. using the node syntax like (res.setHeader())

- so to send the response from the express application... we can use middleware
  - if we passed a res.send() in 1st middleware... the request will not go through the next / 2nd middleware... until unless next() is called inside 1st middleware.

- so we use "res.send()" to send the responses from any middleware
- headers are set on default with express but we can overwrite them using 'res.setHeader()'

snippet:
---
const http = require('http')
const express = require('express')
const app = express()

// 1st middleware
app.use((req, res, next) => {
  console.log('In 1st middleware')
  res.send('<h1>hello this is express</h1>')
  // next()                                       // unless next() is called the response will not reach the next middleware
})

// 2nd middleware
app.use((req, res, next) => {
  console.log('Inside 2nd middleware')
})

const server = http.createServer(app)
server.listen(3000)

Note: the middlewares are executed from top to bottom in an application
---
Note
---
- without using:
const server = http.createServer(app)
server.listen(3000)

- we can use directly:
app.listen(3000)

- the above is to start the server on port: 3000
____________________________________________________________________________________________________________________________________________________________________________________________________

Handling Different Routes
-------------------------
- app.use() can be used in "+4 overloads" that is +4 different ways.

- app.use() takes in a path and a callback function that is (req, res, next) => {}

snippet
---
- app.use('path', (req, res, next) => {
  res.send()
  next()
})

- path (or) path-filter can be "/" route that is all response is send to all routes

snippet
---
const express = require('express')
const app = express()

// 1st middleware
app.use('/', (req, res, next) => {
  console.log('In 1st middleware')
  res.send('<h1>hello this is express</h1>')
})

app.listen(3000)

Note
---
- the above code will send the response to any path... it just checks for the path to start with just '/'
- so whether it is just http://localhost:3000/ (or) http://localhost:3000/hello (or) another route... it will send the response that we send


another snippet:
---
const express = require('express')
const app = express()

// 1st middleware
app.use('/product', (req, res, next) => {
  console.log('In 1st middleware')
  res.send('<h1>hello this is express</h1>')
  next()
})

// 2nd middleware
app.use('/', (req, res, next) => {
  console.log('Inside 2nd middleware');
  res.send('<h2>This is another route</h2>')
})

app.listen(3000)

explanation
---
- from the above code... as next() is not called inside 1st middleware the next middleware shall not be executed, however it does (explanation is provided below...)

1. Request to /product:
---
- Logs In 1st middleware.
- Sends response <h1>hello this is express</h1>.
- Second middleware is not executed.

2. Request to /:
---
- First middleware does not match, so it is skipped.
- Logs Inside 2nd middleware and Sends response <h2>This is another route</h2>.

