More on Arrays & Iterables?
--------------------------

what are 'Iterables' and 'Array-Like Objects'?
---

what is an iterable?
---
- objects where we can use "for-of" loop
- not every iterable is an array (maps, sets...)

what is an Array-Like Objects?
---
- objects that have a length property and use indexes to access items
- not every array-like object is an array (strings)
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Creating Arrays
---------------
1. const array1 = [1, 2, 3]

2. using 'new' keyword
  - const arr2 = new Array()                    // [] >>> empty array
  - const arr2 = new Array('hi', 'world')       // ['hi', 'world']
  - const arr2 = new Array(1, 5)                // [1, 5]

- it is normal if we pass more than one number inside an array ...
  - when we pass only a number as an argument

  const arr2 = new Array(5)
- this creates an empty array with length = 5 (it has 5 empty spaces)
- if we pass in single number ... it is treated as the length of that array

3. using Array.of()
  - const arr3 = Array.of(1, 2)

-----------------------------------------------------------------------------------------------

4. using Array.from()
  - this takes in an 'iterable' or an 'array-like object' which then converts it into an array

ex: Array.from('array')     // ['a', 'r', 'r', 'a', 'y']
- this converts array-like object or an iterable such as a string to an array

use-case:
---
on DOM, if we have list items (li)...

- console.log(document.querySelectorAll('li'))
/> returns all the list items on DOM in the form of "NODE-LIST"
note: NODE-LIST is not an array-like object

- we can convert these list items into an array
  - const arrayListItems = Array.from ( document.querySelectorAll( 'li' ) )
  - clg(arrayListItems)
/> returns a real array and we can apply any real array methods on it ... that we can not on node-list
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Splice() Method
---------------
1. takes 2 arguments (starting index, number of elements to remove)
      const arr = [1, 2, 3]
      arr.splice(0, 1)
  /> starts from index: 0 and removes one element
  /> [2, 3]

2. takes 3 argv (starting index, number of elements to remove, element that replaces after removing)
      const arr = [1, 2, 3, 4]
      arr.splice(0, 2, 'hi')
  >/ ['hi', 3, 4]

Note:
- splice() can take in negative index also
- but arrays will not support negative index >> returns 'undefined'


Slice() Method
--------------

1. copying elements of an array:
---
  - slice() copies an array and stores in memory with a new address

    const arr1 = [1, 2, 3]
    const arr2 = arr1
  >/ both arr1 and arr2 contains same elements and when we change the arr1 in turn effects the arr2

    const arr1 = [1, 2, 3]
    const arr2 = arr1.slice()
    arr1.push(4)
  >/ here arr2 gets a copy of arr1 into it ... so whenever we change arr1 it does not effect the arr2
  >/ arr1: [1,2,3,4] & arr2: [1,2,3]

2. slice() when takes in arguments
---
  - it takes 'start' and 'end' as number types (starting and ending index)
    - selects a range of elements in an array from elements starting to end-1 index
  - as we can not select range of elements with normal array indexing

    const arr1 = [1, 2, 3, 4, 5]
    aar1.slice(0, 2)
  >/ [1, 2]


Concat() Method
---------------
- takes in an array of elements
  - this method will create a copy of an existing array and add the elements passed to the copied array


indexOf() and lastIndexOf() methods
-----------------------------------
- these takes in the element and retrieve the indexes they were in
  - indexOf()... searches from left and lastIndexOf() searches from right

  - this only works for primitive values not for reference values inside an array

    const arr = [{ name: "harsha" }]
    arr.indexOf({ name: "harsha" })
  >/ returns '-1' as result if indexOf() or lastIndexOf() could not find any element

find() and findIndex() methods
------------------------------
- as indexOf and lastIndexOf does not work for reference data types ... we have find and findIndex methods for searching reference elements

  - we have find and findIndex methods which takes another function as an argument ...
    iterates over the array ...
      returns a boolean for the what we are looking inside an array of reference objects

  find:
  ---
  const arr = [{ name: 'one' }, { name: 'two' }]
  const two = arr.find((person) => {
    return person.name === 'two'
  })
  console.log(two)

  >/ {return person.name === 'two'} => returns a boolean
  >/ stores the element that we are looking for inside the variable

  >/ returns: { name: 'two' }

  Note:
    - returns an exact element from the array but not the copy of the element

  findIndex:
  ---
  const one = arr.findIndex((person) => {
    return person.name === 'one'
  })
  console.log(one)

  - returns the exact index of the element we are searching for
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

forEach() loop
--------------
- alternative to for-of loop to iterate over values in an array

  const prices = [10, 13, 12]
  const tax = 0.1
  const pricesWithTaxes = []
  for (const price of prices) {
    pricesWithTaxes.push(price * (1 + tax))
  }
  console.log(pricesWithTaxes)

  - instead of for-of we can use for-each to iterate over the loop
    - takes in a callback function and has access to each element and it's index also

    const prices = [10, 13, 12]
    const tax = 0.1
    const pricesWithTaxes = []
    prices.forEach((price, index) => {
        const obj = { index: index, priceTax: (price * (1 + tax)) }
        pricesWithTaxes.push(obj)
      // pricesWithTaxes.push(price * (1 + tax))
    })
    console.log(pricesWithTaxes)

    >/ returns:
    [
      { index: 0, priceTax: 11 },
      { index: 1, priceTax: 14.3 },
      { index: 2, priceTax: 13.200000000000001 }
    ]

Map Method
----------
- works on arrays and returns a new array with new address in the memory and the original array is untouched

  const prices = [10, 13, 12]
  const tax = 0.1
  const newArr = prices.map((price, index) => {
    return obj = { index: index, priceTax: (price * (1 + tax)) }
  })
  console.log(newArr)

sort() Method
-------------
- using normal sort() method
  - sorts the array elements on changing the elements into strings so '10' < '3'
  - so, we can not use normal sort() without if condition

  const arr = [5, 10, 3, 2, 8]
  const arr1 = arr.sort()
  console.log(arr1)

  returns: >/ [ 10, 2, 3, 5, 8 ]

- with if condition:

  const arr = [5, 10, 3, 2, 8]
  const arr1 = arr.sort((a, b) => {
    if(a > b) {
      return 1
    }
    else if (a === b) {
      return 0
    }
    else{
      return -1
    }
  })
  console.log(arr1)

  >/ returns: [ 2, 3, 5, 8, 10 ]

filter() method
---------------
- filter the array on a condition and returns an array

  const arr = [5, 10, 3, 2, 8]
  const arr1 = arr.filter((num, index) => {
    return num <= 5
  })
  console.log(arr1)

  - filters the original array on the condition passed

reduce() method
---------------
- this method reduces an array into a simpler value ...
  - reduce() takes in a 'callback' function and an 'initial' value to start the operation with (2 argv)

  const arr = [5, 10]

  const mul = arr.reduce((prev, cur) => {
    return prev * cur
  }, 1)

  const sum = arr.reduce((prev, cur) => {
    return prev + cur
  }, 0)

  console.log(mul, sum)

  - based on the operation we perform the initial value changes


use-cases:
----------
1.
const originalArray = [{price: 10.99}, {price: 5.99}, {price: 29.99}];
const transformedArray = originalArray.map(obj => obj.price);                         // produces [10.99, 5.99, 29.99]
const sum = transformedArray.reduce((sumVal, curVal) => sumVal + curVal, 0);          // => 46.97

2.
const originalArray = [{price: 10.99}, {price: 5.99}, {price: 29.99}];
const sum = originalArray.reduce((sumVal, curVal) => sumVal + curVal.price, 0);       // => 46.97

3.
const originalArray = [{price: 10.99}, {price: 5.99}, {price: 29.99}];
const sum =
  originalArray
    .map(obj => obj.price)
    .reduce((sumVal, curVal) => sumVal + curVal, 0);                                  // => 46.97

- different use-cases with concise code ... where we can join both "map" and "reduce" methods

